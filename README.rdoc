= Engineer

It makes engines, get it?

== Explanation

Engines are rails apps which can be run from inside other rails apps.

Engineer is a small gem that lets a sufficiently normal rails application quickly become an
engine.  It provides necessary bits of engine anatomy, and also gives the engine author a way to
publish changes (such as migrations) to users as the engine evolves.  This has been a sticking
point in the past, and is one of the few remaining areas of engine support not yet covered by
rails itself.

Engineer targets rails 3 engines hosted inside rails 3 applications.  If you are looking for rails
2.3 support, try the engines plugin (http://rails-engines.org).

== Getting Started

Let's say you have a new rails app named +my_engine+ that you wish to package as an engine.  Drop
this in your +Gemfile+ and do the bundler thing:

<tt>gem "engineer"</tt>

A new generator named <tt>engineer:install</tt> will be available; run it.
 $ rails g engineer:install
       exist  lib
      create  lib/my_engine/engine.rb
      create  lib/my_engine.rb
      create  lib/generators/my_engine/install/install_generator.rb
      create  lib/generators/my_engine/install/templates/my_engine.rake
      create  lib/generators/my_engine/install/USAGE
      create  app/controllers/my_engine
      create  app/controllers/my_engine/application_controller.rb
      remove  app/controllers/application_controller.rb
      append  Rakefile
        gsub  config/routes.rb

The two major take-aways from this are
1. <tt>application_controller.rb</tt> has moved under +my_engine+.
2. Your +Rakefile+ has grown a bit.

The Gory Details below explain more deeply, but for now let's just look at the new +Rakefile+
content:
 $ cat Rakefile 
  # ...

  Engineer::Tasks.new do |gem|
    gem.name = "my_engine"
    gem.summary = %Q{TODO: one-line summary of your engine}
    gem.description = %Q{TODO: longer description of your engine}
    gem.email = "TODO"
    gem.homepage = "TODO"
    gem.authors = ["TODO"]
    gem.require_path = 'lib'
    gem.files =  FileList[
      "[A-Z]*",
      "{app,config,lib,public,spec,test,vendor}/**/*",
      "db/**/*.rb"
    ]

    # Include Bundler dependencies
    Bundler.definition.dependencies.each do |dependency|
      next if dependency.name == "engineer"

      if (dependency.groups & [:default, :production, :staging]).any?
        gem.add_dependency dependency.name, *dependency.requirement.as_list
      else
        gem.add_development_dependency dependency.name, *dependency.requirement.as_list
      end
    end

    # gem is a Gem::Specification... see http://www.rubygems.org/read/chapter/20 for additional settings
  end

If you've used jeweler (http://github.com/technicalpickles/jeweler) before, this should look
eerily familiar.  Engineer engines are shipped as gems, so engineer throws a (very light) wrapper
around jeweler for wrangling the gem-related tasks.  Jeweler in turn keeps your gem's metadata in
the +Rakefile+, so here it is.

<b>Unlike jeweler, dependencies should still be declared in +Gemfile+, and not here.</b>

As you can see, your bundler dependencies will be included in the generated gemspec.

Let's make a gem:
 $ rake build
  (in /Users/phil/Public/code/my_engine)
  Expected VERSION or VERSION.yml to exist. See version:write to create an initial one.

Whoops.  Our gem needs to know what version it is, and we haven't told it.  Start off at 0.0.0 by
 $ rake version:write
  (in /Users/phil/Public/code/my_engine)
  Updated version: 0.0.0

 $ rake build
  (in /Users/phil/Public/code/my_engine)
  Generated: my_engine.gemspec
  my_engine.gemspec is valid.
  rake aborted!
  "FIXME" or "TODO" is not an author

  (See full trace by running task with --trace)

Doh.  Remember all those TODOs (summary, author, etc) in the Rakefile metadata?  Go fill those out.

Once more:
 $ rake build
  (in /Users/phil/Public/code/my_engine)
  Generated: my_engine.gemspec
  my_engine.gemspec is valid.
  WARNING:  no rubyforge_project specified
    Successfully built RubyGem
    Name: my_engine
    Version: 0.0.0
    File: my_engine-0.0.0.gem

There we go, there's an engine gem sitting in <tt>pkg/</tt>, go nuts.  See jeweler's documentation
for managing the version, pushing to gemcutter and other goodies.

== Using Engine Gems

How about the other side of the fence?  To install an engine into a host application, the host
author follows a similar workflow.

First, add a line to the +Gemfile+ and call bundler:

<tt>gem "my_engine"</tt>

A new generator will be available, named <tt>my_engine:install</tt>; run it.
 $ rails g my_engine:install
       exist  lib/tasks
      create  lib/tasks/my_engine.rake

Some new rake tasks are available:
 $ rake -T my_engine
  (in /Users/phil/Public/code/host)
  rake my_engine:assets      # Link (or copy) my_engine's static assets
  rake my_engine:db:migrate  # Import my_engine's migrations
  rake my_engine:db:seed     # Load my_engine's seed data
  rake my_engine:update      # Update all of my_engine's related resources

Catch-all tasks are also available:
 $ rake -T engines
  (in /Users/phil/Public/code/host)
  rake engines:assets      # Link (or copy) static assets from all engines
  rake engines:db:migrate  # Import migrations from all engines
  rake engines:db:seed     # Load seed data from all engines
  rake engines:update      # Update related resources from all engines

These let the host author manage the newly-installed (or updated!) engine.  Let's get any pending
migrations:
 $ rake my_engine:db:migrate
  (in /Users/phil/Public/code/host)
  mkdir -p db/migrate
  db/migrate/20100420231621_my_engine_create_posts.rb

This doesn't actually run any engine migrations, but instead copies new ones (with mild munging)
to <tt>db/migrate</tt>.  The host author is free to take a peek at them before deciding to
<tt>rake db:migrate</tt> for real.

Now lets wire up the engine's static assets (stylesheets, images and so on):
 $ rake my_engine:assets
  (in /Users/phil/Public/code/host)
  rm -rf /Users/phil/Public/code/host/public/my_engine
  ln -s /opt/local/lib/ruby/gems/1.8/gems/my_engine-0.0.0/public /Users/phil/Public/code/host/public/my_engine

Take a peek in <tt>public/</tt>, you've grown a +my_engine+ soft link to the engine's +public+
directory.  Voodoo in the engine takes care of looking there for assets (see Gory Details below.)
If your OS is allergic to symlinks, the files are copied instead.

Run your pending migrations and fire up <tt>rails s</tt>, you're good to go.

== Gory Details

Rails' engine support has become robust with the release of rails 3.  There are still a few pain
points which engineer tries to address.  It does so by making some decisions for you, the engine
author.  In the spirit of openness, the introduced voodoo is not buried inside the engineer gem
but copied into the engine app on installation.  It's your gem, feel free to tailor it to your
needs.

Some intrepid adventurers will ask for an explanation of the generated engine's internals; here is
an overview.

=== Database Migrations

Engine database migrations are a tricky problem.  Luckily for me, some very clever people already
hammered out a workable idea, which engineer implements.

The migrations are packaged in the gem along with the rest of the engine.  When the host author
installs or updates the gem, she runs the <tt><engine_name>:db:migrate</tt> rake task (directly,
or indirectly through <tt><engine_name>:update</tt>.)  This copies the engine migrations into the
host application, changing a few things on the way.

Specifically:
1. The migration numbers are reassigned.
2. The engine name is inserted into the new migration name.

The numbers are reassigned so that the copied migrations preserve their relative order, and yet
occur after all previous migrations in the host application.  This guarantees that the host
application has a linear schema history, by making that history explicit.  Put another way, the
final host migrations should reflect the evolution of the _host_ schema, not the _engine_ schema
from which it was derived.

The engine name is inserted to avoid name collisions.  It allows the engine to see what migrations
have already been copied into the host app; it will not attempt to copy them again.  Changing the
migration name implies changing the contained migration class name as well: the rake task will
normally take care of it.

Interested readers could also check out
* The original discussion: https://rails.lighthouseapp.com/projects/8994/tickets/2058
* James Adam's related blog post: http://interblah.net/plugin-migrations

=== Static Assets and Asset Helpers

Separation of assets is another issue facing engines.  While it is certainly useful to harness the
host's layouts and styling, engines will inescapably need their own stylesheets, scripts, etc.

Rails provides conventions about where those assets live and what they are named, and backs those
conventions up with helpers that "just work."  The problem is (for example), the host and engine
master stylesheets can't both live at <tt>public/stylesheets/application.css</tt>.  So we need two
separate places to keep assets, and a way of hiding this separation when it is convenient.

Many http servers serve static assets more efficiently than dynamic ones generated from frameworks
like rails.  Any serious solution to the problem will need to respect this optimization.  So,
assuming the web server wants to be dumb, the separate asset locations will be apparent in the
URIs.  The browser only fetches the URIs the application gives it, so the application must know to
render engine asset URIs for engine assets, and host asset URIs otherwise.  These URIs are created
by asset tag helpers such as +image_tag+ and +stylesheet_link_tag+.

An engine author could visit each tag and stick (for example) <tt>my_engine/</tt> in front of the
asset names, but that stinks.  It also breaks the engine when run as a normal application.
Instead, the asset helpers called by the engine must create engine asset URIs only when the engine
is run as such.

Enter +asset_path+.  This is an +action_controller+ configuration hook provided by rails to
control how asset URIs are generated.  It can be set on a controller class, and it is inherited by
subclasses.  By default, it provides rails' cache-busting ability (the <tt>?123line-noise456</tt>
on the end of your stylesheet URIs.)  Engineer hijacks it to provide asset separation.

Recall that engineer's install generator moves <tt>application_controller.rb</tt> into an
engine-specific namespace: this is why.  On startup, a <tt>MyEngine::Engine</tt> initializer sets
an +asset_path+ on <tt>MyEngine::ApplicationController</tt>.  Since this controller is no longer
the global +ApplicationController+, we're ensured this +asset_path+ will affect not only all the
engine controllers, but only them.  The initializers in <tt>MyEngine::Engine</tt> are only run
when the application is started as an engine.  Thus when +my_engine+ is fired up as a normal
application, the custom +asset_path+ is not used.

Almost there.  +asset_path+ can take as value either a string template (such as
<tt>"/my_engine%s"</tt>) or a lambda.  If the engine and host authors were not interested in
sharing layouts and other views, <tt>"/my_engine%s"</tt> would be enough.  There, all asset tags
rendered by any view from an engine controller will target the engine's assets.  This goes bad
when an engine view wants to render with a host layout that includes a stylesheet: the stylesheet
URI would point into the engine, not the host.

A little more (and arguably too much) leg work can save us.  The flaw is that we want the
customized URI not when requesting an engine _controller_, but when rendering an engine _view_.
If you have one around, open up <tt>lib/my_engine/engine.rb</tt>.  There is another initializer in
there that duck punches <tt>ActionView::Template#render</tt>.  When a template is rendered, its
+identifier+ is captured.  For templates loaded from files, this is a file system path descending
from a <tt>config.paths.app.views</tt> of either the host or the engine.  Thus we can distinguish
host templates from engine templates.  Engine assets are generated for engine views and non-file
system views.

== Running the Tests

The (sparse) tests are written with cucumber (http://cukes.info) and can be run with just "rake".
You may need to install jeweler first.

== Thanks

This tool would not exist if the road had not already been well-paved by many others.
Specifically, James Adam's herculean effort in the rails 2.3 engines plugin has illuminated many
issues and solutions.  Thanks also to the rails core team for incorporating many engine-centric
ideas into the framework, vastly simplifying what this tool needs to do.  And also for just making
an awesome framework.

Finally, thanks to SEOmoz (http://seomoz.org) for letting me build this at my desk in the
afternoons instead of on the couch in the middle of the night ^_^.

== Copyright

Copyright (c) 2009-2010 Philip Smith. See LICENSE for details.
